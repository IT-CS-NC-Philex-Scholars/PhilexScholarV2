name: Auto Pre-release and Docker Tag

on:
  push:
    branches: [ develop, main ]

permissions:
  contents: write
  packages: write

env:
  REGISTRY: docker.io
  IMAGE_NAME: yukazaki/philexscholarv2

jobs:
  analyze-commit:
    runs-on: ubuntu-latest
    if: github.actor != 'github-actions[bot]'
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      release_type: ${{ steps.version.outputs.release_type }}
      should_release: ${{ steps.version.outputs.should_release }}
      is_main: ${{ steps.version.outputs.is_main }}
      commit_message: ${{ steps.version.outputs.commit_message }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Analyze commit and determine version
        id: version
        shell: bash
        run: |
          set -euo pipefail

          git fetch --tags --force

          # Get commit message (first line only)
          COMMIT_MSG=$(git log -1 --pretty=%B | head -n1)
          echo "Commit message: $COMMIT_MSG"
          {
            echo 'commit_message<<EOF'
            echo "$COMMIT_MSG"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

          # Determine bump based on commit message
          if [[ "$COMMIT_MSG" =~ ^(feat|feature)[:\(] ]]; then
            RELEASE_TYPE="feature"
            BUMP="minor"
          elif [[ "$COMMIT_MSG" =~ ^(fix|bugfix)[:\(] ]]; then
            RELEASE_TYPE="bugfix"
            BUMP="patch"
          elif [[ "$COMMIT_MSG" =~ ^(break|major|breaking)[:\(] ]]; then
            RELEASE_TYPE="major"
            BUMP="major"
          elif [[ "$COMMIT_MSG" =~ ^(chore|docs|style|refactor|test)[:\(] ]]; then
            RELEASE_TYPE="chore"
            BUMP="patch"
          else
            RELEASE_TYPE="patch"
            BUMP="patch"
          fi

          echo "Release type: $RELEASE_TYPE"
          echo "Bump type: $BUMP"
          echo "release_type=$RELEASE_TYPE" >> "$GITHUB_OUTPUT"

          # Base version from latest *stable* semver tag (ignores prerelease tags)
          LATEST_STABLE_TAG=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | head -n1 || true)
          if [ -n "${LATEST_STABLE_TAG:-}" ]; then
            BASE_VERSION="${LATEST_STABLE_TAG#v}"
          else
            BASE_VERSION="1.0.0"
          fi

          echo "Base version: $BASE_VERSION"

          # Calculate new stable version
          case "$BUMP" in
            major)
              NEW_VERSION=$(echo "$BASE_VERSION" | awk -F. '{print $1+1".0.0"}')
              ;;
            minor)
              NEW_VERSION=$(echo "$BASE_VERSION" | awk -F. '{print $1"."$2+1".0"}')
              ;;
            patch)
              NEW_VERSION=$(echo "$BASE_VERSION" | awk -F. '{print $1"."$2"."$3+1}')
              ;;
            *)
              NEW_VERSION="$BASE_VERSION"
              ;;
          esac

          # Create a prerelease tag for develop that won't collide with existing tags
          PRERELEASE_PREFIX="dev"
          PATTERN="v${NEW_VERSION}-${PRERELEASE_PREFIX}.*"
          MAX_N=$(git tag -l "$PATTERN" | awk -F'.' '/\.[0-9]+$/{n=$NF+0; if(n>max)max=n} END{print max+0}')
          N=$((MAX_N + 1))

          TAG="v${NEW_VERSION}-${PRERELEASE_PREFIX}.${N}"
          while git rev-parse "$TAG" >/dev/null 2>&1; do
            N=$((N + 1))
            TAG="v${NEW_VERSION}-${PRERELEASE_PREFIX}.${N}"
          done

          VERSION="${NEW_VERSION}-${PRERELEASE_PREFIX}.${N}"

          echo "Resolved prerelease tag: $TAG"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"

          # This workflow runs on develop only
          echo "should_release=true" >> "$GITHUB_OUTPUT"
          echo "is_main=false" >> "$GITHUB_OUTPUT"

  build-and-push:
    runs-on: ubuntu-latest
    needs: analyze-commit
    if: always() && needs.analyze-commit.result == 'success'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ needs.analyze-commit.outputs.tag }}
            type=raw,value=dev-latest
            type=raw,value=${{ needs.analyze-commit.outputs.release_type }}-${{ github.sha }}
            type=ref,event=branch
          labels: |
            org.opencontainers.image.version=${{ needs.analyze-commit.outputs.version }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
            org.opencontainers.image.title=DccpAdminV3
            org.opencontainers.image.description=Divine Cross College Portal - Admin Dashboard V3
            org.opencontainers.image.vendor=DCCP

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64
          build-args: |
            APP_NAME=PhilexScholarV2
            APP_ENV=production
            APP_DEBUG=false
            APP_URL=https://philex.yukazaki.com 

  create-release:
    runs-on: ubuntu-latest
    needs: [analyze-commit, build-and-push]
    if: needs.build-and-push.result == 'success' && needs.analyze-commit.outputs.should_release == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        shell: bash
        run: |
          set -euo pipefail

          VERSION="${{ needs.analyze-commit.outputs.version }}"
          TAG="${{ needs.analyze-commit.outputs.tag }}"
          RELEASE_TYPE="${{ needs.analyze-commit.outputs.release_type }}"
          COMMIT_MSG="${{ needs.analyze-commit.outputs.commit_message }}"

          # Get commits since last tag (if any)
          LAST_TAG=$(git describe --tags --abbrev=0 --match "v*" HEAD^ 2>/dev/null || echo "")

          if [ -n "$LAST_TAG" ]; then
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" ${LAST_TAG}..HEAD)
          else
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" HEAD)
          fi

          cat > RELEASE_NOTES.md << EOF
          # DccpAdminV3 ${TAG} (Pre-release)

          ðŸš§ **Channel:** Develop / Rolling pre-release
          ðŸš€ **Release Type:** ${RELEASE_TYPE^}
          ðŸ“¦ **Version:** ${VERSION}
          ðŸ³ **Docker Image:** ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}
          ðŸ³ **Docker Alias:** ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-latest

          ## ðŸ“‹ Changes
          ${CHANGELOG}

          ## ðŸŽ¯ Latest Commit
          ${COMMIT_MSG}

          ## ðŸ³ Docker Deployment
          \`\`\`bash
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}

          # Or pull the rolling develop alias
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-latest
          \`\`\`

          ---
          ðŸ¤– *Auto-generated pre-release from commit ${{ github.sha }}*
          ðŸ“Š *Build: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}*
          EOF

      - name: Create Git tag (idempotent)
        shell: bash
        run: |
          set -euo pipefail

          TAG="${{ needs.analyze-commit.outputs.tag }}"

          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists; skipping creation."
            exit 0
          fi

          git tag -a "$TAG" -m "Pre-release $TAG"
          git push origin "$TAG"

      - name: Create GitHub Pre-release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.analyze-commit.outputs.tag }}
          name: DccpAdminV3 Pre-release ${{ needs.analyze-commit.outputs.tag }}
          body_path: RELEASE_NOTES.md
          draft: false
          prerelease: true
          files: |
            version.json
          generate_release_notes: false

  update-version:
    runs-on: ubuntu-latest
    needs: [analyze-commit, build-and-push, create-release]
    if: always() && needs.analyze-commit.result == 'success' && needs.build-and-push.result == 'success' && (needs.create-release.result == 'success' || needs.create-release.result == 'skipped')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Update version.json
        shell: bash
        run: |
          set -euo pipefail

          VERSION="${{ needs.analyze-commit.outputs.version }}"
          TAG="${{ needs.analyze-commit.outputs.tag }}"
          RELEASE_TYPE="${{ needs.analyze-commit.outputs.release_type }}"
          COMMIT_MSG="${{ needs.analyze-commit.outputs.commit_message }}"

          PREVIOUS_VERSION="1.0.0"
          if [ -f "version.json" ]; then
            PREVIOUS_VERSION=$(jq -r '.version // "1.0.0"' version.json 2>/dev/null || echo "1.0.0")
          fi

          cat > version.json << EOF
          {
            "version": "${VERSION}",
            "image": "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}",
            "commit": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "build_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "release_type": "${RELEASE_TYPE}",
            "changelog": {
              "current": "Version ${VERSION} - ${COMMIT_MSG}",
              "previous": "${PREVIOUS_VERSION}"
            },
            "metadata": {
              "author": "${{ github.actor }}",
              "workflow": "${{ github.workflow }}",
              "repository": "${{ github.repository }}"
            }
          }
          EOF

          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add version.json
          git diff --staged --quiet || git commit -m "chore: update version to ${VERSION} [skip ci]"
          git push

  notify:
    runs-on: ubuntu-latest
    needs: [analyze-commit, build-and-push, create-release, update-version]
    if: always()
    env:
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 50

      - name: Send notification
        shell: bash
        run: |
          echo "ðŸ“¢ Auto Pre-release Summary"
          echo "=========================="

          echo "ðŸ“¦ Version: ${{ needs.analyze-commit.outputs.version }}"
          echo "ðŸ·ï¸  Tag: ${{ needs.analyze-commit.outputs.tag }}"
          echo "ðŸŽ¯ Type: ${{ needs.analyze-commit.outputs.release_type }}"
          echo "ðŸ³ Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.analyze-commit.outputs.tag }}"
          echo "ðŸ³ Alias: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-latest"
          echo "ðŸ‘¤ Author: ${{ github.actor }}"
          echo "ðŸŒ¿ Branch: ${{ github.ref_name }}"
          echo "ðŸ“ Commit: ${{ needs.analyze-commit.outputs.commit_message }}"

          echo "ðŸ“Š Build: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          echo "ðŸŽ‰ Pre-release: ${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ needs.analyze-commit.outputs.tag }}"

      - name: Send Discord notification
        if: ${{ env.DISCORD_WEBHOOK_URL != '' }}
        env:
          BUILD_RESULT: ${{ needs.build-and-push.result }}
          RELEASE_RESULT: ${{ needs.create-release.result }}
          VERSION_RESULT: ${{ needs.update-version.result }}
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "$DISCORD_WEBHOOK_URL" ]; then
            echo "No Discord webhook configured; skipping notification"
            exit 0
          fi

          status_icon() {
            case "$1" in
              success) echo "âœ…" ;;
              skipped) echo "â­ï¸" ;;
              cancelled) echo "âšª" ;;
              *) echo "âŒ" ;;
            esac
          }

          BUILD_ICON=$(status_icon "$BUILD_RESULT")
          RELEASE_ICON=$(status_icon "$RELEASE_RESULT")
          VERSION_ICON=$(status_icon "$VERSION_RESULT")

          if [ "$BUILD_RESULT" = "success" ]; then
            COLOR=5763719
            SUMMARY="Build succeeded"
          else
            COLOR=15548997
            SUMMARY="Build failed"
          fi

          RECENT_CHANGES=$(git log -5 --pretty=format:"- %s (%an)" HEAD 2>/dev/null || true)
          if [ -z "${RECENT_CHANGES:-}" ]; then
            RECENT_CHANGES="(No additional commits detected)"
          fi

          CONTRIBUTORS=$(git log -20 --pretty=format:"%an" HEAD 2>/dev/null | awk '!seen[$0]++' | head -n 10 | paste -sd ', ' - 2>/dev/null || true)
          if [ -z "${CONTRIBUTORS:-}" ]; then
            CONTRIBUTORS="${{ github.actor }}"
          fi

          RELEASE_URL="${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ needs.analyze-commit.outputs.tag }}"

          PAYLOAD=$(jq -n \
            --arg summary "$SUMMARY" \
            --arg build "$BUILD_ICON Build: $BUILD_RESULT" \
            --arg release "$RELEASE_ICON Release: $RELEASE_RESULT" \
            --arg version "$VERSION_ICON Version File: $VERSION_RESULT" \
            --arg versionLabel "${{ needs.analyze-commit.outputs.version }}" \
            --arg tag "${{ needs.analyze-commit.outputs.tag }}" \
            --arg type "${{ needs.analyze-commit.outputs.release_type }}" \
            --arg branch "${{ github.ref_name }}" \
            --arg actor "${{ github.actor }}" \
            --arg commit "${{ needs.analyze-commit.outputs.commit_message }}" \
            --arg buildUrl "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --arg docker "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.analyze-commit.outputs.tag }}" \
            --arg dockerAlias "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-latest" \
            --arg releaseUrl "$RELEASE_URL" \
            --arg changes "$RECENT_CHANGES" \
            --arg contributors "$CONTRIBUTORS" \
            --argjson color "$COLOR" \
            '{
              "username": "DCCP Release Bot",
              "embeds": [
                {
                  "title": "Develop Pre-release â€¢ \($summary)",
                  "color": $color,
                  "description": "**Version:** \($versionLabel)\n**Tag:** \($tag)\n**Type:** \($type)",
                  "fields": [
                    { "name": "Pipeline", "value": $buildUrl, "inline": false },
                    { "name": "Docker Image", "value": $docker, "inline": false },
                    { "name": "Docker Alias", "value": $dockerAlias, "inline": false },
                    { "name": "Build Stage", "value": $build, "inline": true },
                    { "name": "Release Stage", "value": $release, "inline": true },
                    { "name": "Version File", "value": $version, "inline": true },
                    { "name": "Branch", "value": $branch, "inline": true },
                    { "name": "Actor", "value": $actor, "inline": true },
                    { "name": "Commit", "value": $commit, "inline": false },
                    { "name": "Latest Changes", "value": $changes, "inline": false },
                    { "name": "Contributors", "value": $contributors, "inline": false }
                  ],
                  "footer": {
                    "text": "Pre-release details - \($releaseUrl)"
                  },
                  "timestamp": "'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"
                }
              ]
            }')

          curl -X POST \
            "$DISCORD_WEBHOOK_URL" \
            -H 'Content-Type: application/json' \
            -d "$PAYLOAD"
